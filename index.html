<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Optim’Angle Solaire</title>
  <style>
    :root{
      --bg:#0b1220;--card:#121a2b;--muted:#7b8aa5;--fg:#e9f0ff;--accent:#41d1b7;--warn:#ffcc00;--bad:#ff6b6b;
    }
    html,body{height:100%;}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0a0f1a 80%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";}
    .wrap{max-width:1000px;margin:0 auto;padding:16px 16px 120px;}
    header{display:flex;gap:12px;align-items:center;}
    h1{font-size:clamp(22px,3vw,32px);margin:8px 0 0}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);box-shadow:0 8px 30px rgba(0,0,0,.35);border-radius:18px;padding:16px;margin-top:16px}
    .row{display:flex;flex-wrap:wrap;gap:12px}
    .col{flex:1 1 260px}
    .btn{appearance:none;border:0;background:var(--accent);color:#00110e;font-weight:700;padding:14px 16px;border-radius:14px;cursor:pointer;transition:transform .05s ease,opacity .2s;}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:#2a3957;color:var(--fg)}
    .btn.ghost{background:transparent;border:1px dashed #3a4a6a;color:var(--fg)}
    .btn.full{width:100%}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .kv{background:#0e1423;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px}
    .kv h3{margin:0 0 6px;font-size:12px;letter-spacing:.08em;color:var(--muted);text-transform:uppercase}
    .kv .val{font-feature-settings:"tnum" 1; font-variant-numeric:tabular-nums; font-size:22px}
    .hint{color:var(--muted);font-size:13px}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0e1423;border:1px solid rgba(255,255,255,.08)}
    .ok{color:#00e18a}
    .warn{color:var(--warn)}
    .bad{color:var(--bad)}
    .footer{position:fixed;left:0;right:0;bottom:0;background:linear-gradient(180deg,rgba(11,18,32,.0),rgba(11,18,32,.9) 35%,rgba(11,18,32,1));padding:14px}
    .footer .bar{max-width:1000px;margin:0 auto;display:flex;gap:10px}
    label.switch{display:inline-flex;align-items:center;gap:8px}
    input[type=checkbox]{width:18px;height:18px}
    code{background:#0e1423;border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:2px 6px}
    details{opacity:.95}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <svg width="42" height="42" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="6" stroke="#41d1b7" stroke-width="2"/><path d="M12 1v3M12 20v3M1 12h3M20 12h3M4.2 4.2l2.2 2.2M17.6 17.6l2.2 2.2M19.8 4.2l-2.2 2.2M6.4 17.6l-2.2 2.2" stroke="#41d1b7" stroke-width="2" stroke-linecap="round"/></svg>
      <div>
        <h1>Optim’Angle Solaire</h1>
        <div class="hint">Posez le smartphone <strong>face contre le panneau</strong>, sur un coin, bien perpendiculaire au bord. Puis activez les capteurs et enregistrez.</div>
      </div>
    </header>

    <div class="card">
      <div class="row">
        <div class="col">
          <button id="btnGeo" class="btn full">📍 Autoriser la géolocalisation</button>
        </div>
        <div class="col">
          <button id="btnSensors" class="btn full">🧭 Activer les capteurs</button>
        </div>
        <div class="col">
          <button id="btnSnap" class="btn secondary full" disabled>📸 Enregistrer la mesure</button>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <label class="switch">
          <input type="checkbox" id="flipPhone" />
          <span>Mon téléphone est posé <strong>écran vers le bas</strong> (recommandé)</span>
        </label>
        <label class="switch">
          <input type="checkbox" id="leftCorner" />
          <span>Je suis sur le <strong>coin gauche</strong> (par défaut : coin droit)</span>
        </label>
      </div>
      <div class="small" style="margin-top:8px">Si les capteurs ne s’activent pas : assurez‑vous d’être en <strong>HTTPS</strong> (ou application Android), puis cliquez sur « Activer les capteurs » et acceptez les permissions.
      </div>
    </div>

    <div class="card">
      <div class="grid">
        <div class="kv"><h3>Position</h3><div class="val" id="latlon">—</div><div class="hint" id="tz">Fuseau : —</div></div>
        <div class="kv"><h3>Horodatage</h3><div class="val" id="ts">—</div><div class="hint">UTC / local</div></div>
        <div class="kv"><h3>Azimut solaire</h3><div class="val" id="sunAz">—</div><div class="hint">0° = Nord, 90° = Est</div></div>
        <div class="kv"><h3>Hauteur solaire</h3><div class="val" id="sunEl">—</div><div class="hint">Élévation au-dessus de l’horizon</div></div>
      </div>
      <div class="grid" style="margin-top:12px">
        <div class="kv"><h3>Azimut panneau (mesuré)</h3><div class="val" id="panAz">—</div><div class="hint">Estimé via boussole</div></div>
        <div class="kv"><h3>Inclinaison panneau (mesurée)</h3><div class="val" id="panTilt">—</div><div class="hint">0° = à plat, 90° = vertical</div></div>
        <div class="kv"><h3>Inclinaison <span class="pill">recommandée</span></h3><div class="val" id="tiltOpt">—</div><div class="hint" id="recNote">Principe : optimisation instantanée</div></div>
        <div class="kv"><h3>Incidence min. atteignable</h3><div class="val" id="incidence">—</div><div class="hint">Angle rayon ↔ normal du panneau</div></div>
      </div>
      <div id="quality" class="hint" style="margin-top:10px"></div>
    </div>

    <div class="card">
      <details>
        <summary>⚙️ Options & Outils (avancé)</summary>
        <div class="row" style="margin-top:10px">
          <button id="btnZero" class="btn ghost">Zéro capteurs (calibration douce)</button>
          <button id="btnSim" class="btn ghost">Simuler une mesure</button>
          <button id="btnPVGIS" class="btn ghost">Comparer avec PVGIS (beta)</button>
        </div>
        <p class="small">La valeur <em>recommandée</em> est calculée pour minimiser l’angle d’incidence <code>θ</code> entre le rayon solaire et la normale du panneau <strong>en ne modifiant que l’inclinaison</strong> (azimut fixe tel que mesuré). Formule : si le zénith solaire vaut <code>ζ = 90° − élévation</code> et <code>Δ = azimut_solaire − azimut_panneau</code>, alors <code>tan(tilt_opt) = tan(ζ) · cos(Δ)</code>, bornée à [0°, 90°]. L’incidence minimale obtenue est <code>θ_min = arccos(cos ζ · cos τ + sin ζ · sin τ · cos Δ)</code> avec <code>τ = tilt_opt</code>. Si <code>cos Δ &lt; 0</code> (soleil derrière le panneau), l’application signale une orientation défavorable.</p>
      </details>
    </div>

    <div class="footer">
      <div class="bar">
        <div class="pill">État capteurs : <span id="state" class="warn">inactifs</span></div>
        <div class="pill">Précision boussole : <span id="acc">—</span></div>
        <div class="pill">HTTPS : <span id="https">—</span></div>
      </div>
    </div>
  </div>

  <script>
    // ======= Utilitaires UI =======
    const $ = (id)=>document.getElementById(id);
    const fmtDeg = (x)=> Number.isFinite(x)? `${x.toFixed(1)}°` : '—';
    const clamp = (x,a,b)=> Math.min(Math.max(x,a),b);
    const norm360 = (a)=> (a%360+360)%360;
    const deg2rad = (d)=> d*Math.PI/180;
    const rad2deg = (r)=> r*180/Math.PI;

    // ======= État global =======
    const st = {
      lat:null, lon:null, tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
      sunAz:null, sunEl:null,
      panAz:null, panTilt:null,
      // compensations
      zero:{alpha:0,beta:0,gamma:0},
      headingAcc:null,
      sensorsOn:false,
    };

    // ======= Géolocalisation =======
    function askGeo(){
      if(!('geolocation' in navigator)){ alert('Géolocalisation non disponible'); return; }
      navigator.geolocation.getCurrentPosition(pos=>{
        st.lat = pos.coords.latitude; st.lon = pos.coords.longitude;
        $('latlon').textContent = `${st.lat.toFixed(5)}, ${st.lon.toFixed(5)}`;
        $('tz').textContent = `Fuseau : ${st.tz}`;
        updateSun();
      }, err=>{
        alert('Impossible d\'obtenir la position : '+err.message);
      }, {enableHighAccuracy:true,timeout:8000,maximumAge:0});
    }

    // ======= Soleil (algorithme NOAA simplifié) =======
    function julianDay(date){
      const t = date.getTime()/86400000 + 2440587.5; return t;
    }
    function sunPos(date, lat, lon){
      // Renvoie {az, el} en degrés (azimut depuis le Nord, sens horaire)
      // Source: algorithme simplifié NOAA, précision ~0.5°
      const d = julianDay(date) - 2451545.0;
      const g = deg2rad(norm360(357.529 + 0.98560028*d));
      const q = deg2rad(norm360(280.459 + 0.98564736*d));
      const L = q + deg2rad(1.915)*Math.sin(g) + deg2rad(0.020)*Math.sin(2*g);
      const e = deg2rad(23.439 - 0.00000036*d);
      const ra = Math.atan2(Math.cos(e)*Math.sin(L), Math.cos(L));
      const dec = Math.asin(Math.sin(e)*Math.sin(L));
      const GMST = norm360(280.1600 + 360.9856235*d);
      const LST = deg2rad(norm360(GMST + lon));
      const HA = LST - ra; // angle horaire
      const latR = deg2rad(lat);
      const el = Math.asin(Math.sin(latR)*Math.sin(dec) + Math.cos(latR)*Math.cos(dec)*Math.cos(HA));
      const az = Math.atan2(-Math.sin(HA), Math.tan(dec)*Math.cos(latR) - Math.sin(latR)*Math.cos(HA));
      // azimut depuis le Nord (0), sens horaire
      let azDeg = norm360(rad2deg(az));
      let elDeg = rad2deg(el);
      return {az:azDeg, el:elDeg};
    }

    function updateSun(){
      if(st.lat==null||st.lon==null){ return; }
      const now = new Date();
      const s = sunPos(now, st.lat, st.lon);
      st.sunAz = s.az; st.sunEl = s.el;
      $('ts').textContent = now.toLocaleString();
      $('sunAz').textContent = fmtDeg(s.az);
      $('sunEl').textContent = fmtDeg(s.el);
      computeRecommendation();
    }

    // ======= Capteurs (boussole + orientation) =======
    const httpsOk = location.protocol === 'https:' || location.protocol === 'file:'; // Capacitor/Android = file:
    $('https').textContent = httpsOk ? 'OK' : 'non sécurisé';

    async function requestIOSPermission(){
      try{
        // iOS 13+
        if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const p = await DeviceOrientationEvent.requestPermission();
          if(p !== 'granted') throw new Error('Permission orientation refusée');
        }
        if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          const p2 = await DeviceMotionEvent.requestPermission();
          if(p2 !== 'granted') throw new Error('Permission motion refusée');
        }
      }catch(e){ console.warn(e); }
    }

    let orientationHandler=null, compassHandler=null, compassHeading=null;

    function startSensors(){
      if(!httpsOk){ alert('Les capteurs nécessitent HTTPS ou une app Android.'); return; }
      requestIOSPermission();
      // Device orientation (beta, gamma, absolute)
      orientationHandler = (ev)=>{
        const {alpha, beta, gamma} = ev; // degrés
        // beta: rotation autour de l'axe X (-180 à 180) | gamma: autour de Y (-90 à 90)
        let b = (beta??0) - st.zero.beta;
        let g = (gamma??0) - st.zero.gamma;
        const faceDown = $('flipPhone').checked; // si écran vers le bas, on inverse l'axe Z
        if(faceDown){ b = -b; g = -g; }
        // Inclinaison panneau = angle à partir de l'horizontale
        // Approximation robuste: tilt = acos(|z|) où z ≈ cos(beta) * cos(gamma)
        const z = Math.cos(deg2rad(b)) * Math.cos(deg2rad(g));
        const tilt = clamp(rad2deg(Math.acos(Math.min(1,Math.max(-1, Math.abs(z) )))), 0, 90);
        st.panTilt = tilt;
        $('panTilt').textContent = fmtDeg(tilt);
        computeRecommendation();
      };
      window.addEventListener('deviceorientation', orientationHandler, {once:false, passive:true});

      compassHandler = (ev)=>{
        // Chrome Android: ev.alpha (0-360) relatif Nord; iOS: webkitCompassHeading (0 = Nord)
        let heading = null;
        if(typeof ev.webkitCompassHeading === 'number' && !isNaN(ev.webkitCompassHeading)){
          // iOS fournit déjà l'azimut vrai en degrés depuis le Nord
          heading = ev.webkitCompassHeading;
          st.headingAcc = ev.webkitCompassAccuracy ?? null;
        } else if(typeof ev.absolute === 'boolean' && ev.absolute && typeof ev.alpha === 'number'){
          // Android/Chromium absolute heading
          heading = 360 - ev.alpha; // convertir en sens horaire depuis le Nord
        } else if(typeof ev.alpha === 'number'){
          heading = 360 - ev.alpha;
        }
        if(heading!=null){
          // ajuster coin gauche/droit : l'utilisateur colle le téléphone perpendiculaire au bord
          const left = $('leftCorner').checked;
          // La normale panneau suit le bord; l'azimut panneau ≈ cap + (left?+90:-90)
          const panAz = norm360( heading + (left? 90 : -90) );
          st.panAz = panAz;
          $('panAz').textContent = fmtDeg(panAz);
          $('acc').textContent = (st.headingAcc!=null)? `${st.headingAcc.toFixed(0)}°` : 'n/d';
          computeRecommendation();
        }
      };
      window.addEventListener('deviceorientationabsolute', compassHandler, {once:false, passive:true});
      window.addEventListener('deviceorientation', compassHandler, {once:false, passive:true});

      st.sensorsOn = true; $('state').textContent = 'actifs'; $('state').className='ok';
      $('btnSnap').disabled = false;
    }

    function stopSensors(){
      if(orientationHandler){ window.removeEventListener('deviceorientation', orientationHandler); }
      if(compassHandler){ window.removeEventListener('deviceorientationabsolute', compassHandler); window.removeEventListener('deviceorientation', compassHandler); }
      st.sensorsOn = false; $('state').textContent = 'inactifs'; $('state').className='warn';
      $('btnSnap').disabled = true;
    }

    function zeroSensors(){ st.zero = {alpha:0,beta:0,gamma:0}; }

    // ======= Recommandation d'inclinaison (Math) =======
    function computeRecommendation(){
      if(st.sunAz==null||st.sunEl==null||st.panAz==null||st.panTilt==null) return;
      const zen = 90 - st.sunEl; // ζ
      const delta = deg2rad( norm360(st.sunAz - st.panAz) ); // Δ en [0..2π)
      const cosD = Math.cos(delta);
      const tanZen = Math.tan(deg2rad(zen));
      let tiltOpt = rad2deg(Math.atan( tanZen * cosD ));
      // borne et valeurs réelles
      if(!Number.isFinite(tiltOpt)) tiltOpt = 90;
      tiltOpt = clamp(tiltOpt, 0, 90);

      // Incidence minimale atteignable pour ce Δ
      const z = deg2rad(zen), t = deg2rad(tiltOpt);
      const cosTheta = Math.cos(z)*Math.cos(t) + Math.sin(z)*Math.sin(t)*cosD;
      const theta = rad2deg(Math.acos( clamp(cosTheta,-1,1) ));

      $('tiltOpt').textContent = fmtDeg(tiltOpt);
      $('incidence').textContent = fmtDeg(theta);

      // Qualité et avertissements
      let msg = '';
      if(cosD < 0){
        msg = '⚠️ Soleil derrière le panneau (Δ > 90°). Gains limités. Envisagez de réorienter l’azimut.';
      } else if(theta < 10){
        msg = '✅ Très bon alignement possible. Ajustez à la valeur recommandée.';
      } else if(theta < 25){
        msg = 'ℹ️ Alignement correct. Un réglage vers la valeur recommandée améliore le rendement.';
      } else {
        msg = '⚠️ Orientation défavorable. Si possible, pivotez le panneau vers le soleil (azimut).';
      }
      $('quality').textContent = msg;
    }

    // ======= Actions UI =======
    $('btnGeo').addEventListener('click', askGeo);
    $('btnSensors').addEventListener('click', ()=>{
      if(!st.sensorsOn) startSensors(); else stopSensors();
    });
    $('btnZero').addEventListener('click', zeroSensors);
    $('btnSim').addEventListener('click', ()=>{
      // Exemple: soleil au SSW, panel Ouest; montre cas extrême Brésil/Ouest
      st.lat = st.lat?? -22.9; st.lon = st.lon?? -43.2; // Rio
      $('latlon').textContent = `${st.lat.toFixed(5)}, ${st.lon.toFixed(5)}`;
      const now = new Date();
      const s = sunPos(now, st.lat, st.lon); st.sunAz = s.az; st.sunEl = s.el;
      $('sunAz').textContent = fmtDeg(s.az); $('sunEl').textContent = fmtDeg(s.el);
      st.panAz = 270; $('panAz').textContent = fmtDeg(270);
      st.panTilt = 25; $('panTilt').textContent = fmtDeg(25);
      computeRecommendation();
    });

    $('btnPVGIS').addEventListener('click', async ()=>{
      if(st.lat==null||st.lon==null||st.panAz==null||st.panTilt==null){ alert('Mesure incomplète.'); return; }
      // Appel simplifié PVGIS (beta). NB: nécessite internet. Les quotas peuvent limiter.
      try{
        const p1 = fetch(`https://re.jrc.ec.europa.eu/api/PVcalc?lat=${st.lat}&lon=${st.lon}&peakpower=1&loss=14&angle=${st.panTilt}&aspect=${st.panAz}&outputformat=json`);
        // recompute opt
        const tmpTilt = parseFloat($('tiltOpt').textContent) || st.panTilt;
        const p2 = fetch(`https://re.jrc.ec.europa.eu/api/PVcalc?lat=${st.lat}&lon=${st.lon}&peakpower=1&loss=14&angle=${tmpTilt}&aspect=${st.panAz}&outputformat=json`);
        const [r1,r2] = await Promise.all([p1,p2]);
        const [j1,j2] = await Promise.all([r1.json(), r2.json()]);
        const e1 = j1.outputs?.totals?.fixed?.E_y;
        const e2 = j2.outputs?.totals?.fixed?.E_y;
        if(e1 && e2){
          const gain = ((e2-e1)/e1*100).toFixed(1);
          alert(`Estimation PVGIS sur 1 kWc\nRéglage actuel: ${e1.toFixed(0)} kWh/an\nRéglage recommandé: ${e2.toFixed(0)} kWh/an\nGain estimé: ${gain}%`);
        } else {
          alert('Réponse PVGIS non exploitable.');
        }
      }catch(e){ alert('PVGIS indisponible : '+e.message); }
    });

    $('btnSnap').addEventListener('click', ()=>{
      if(st.panAz==null||st.panTilt==null||st.sunAz==null) { alert('Mesure incomplète.'); return; }
      // Ici on pourrait sauvegarder localement l’instantané (localStorage)
      const rec = $('tiltOpt').textContent;
      alert(`Mesure enregistrée:\nAzimut panneau: ${fmtDeg(st.panAz)}\nInclinaison panneau: ${fmtDeg(st.panTilt)}\nAzimut solaire: ${fmtDeg(st.sunAz)}\nHauteur solaire: ${fmtDeg(st.sunEl)}\n\nInclinaison recommandée: ${rec}`);
    });

    // Démarrage doux : on tente une geoloc + update soleil toutes les 30 s
    askGeo();
    setInterval(updateSun, 30000);
  </script>
</body>
</html>
